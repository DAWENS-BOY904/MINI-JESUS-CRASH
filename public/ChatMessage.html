<!doctype html>
<html>
<head>
<meta charset="utf-8" /><meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Da-ChatGPT â€” Chat</title>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap" rel="stylesheet">
<style>
  :root {
  --primary:#6c63ff;
  --secondary:#00f7ff;
  --glass:rgba(255,255,255,0.06);
  --radius:14px;
  --shadow:0 8px 32px rgba(0,0,0,0.5);
}

body {
  margin:0;
  font-family:Poppins,system-ui;
  background:#020405;
  color:#eaf6ff;
  display:flex;
  flex-direction:column;
  height:100vh;
  overflow:hidden;
}

/* HEADER */
header {
  position:fixed;
  top:0; left:0; right:0;
  padding:12px 16px;
  background:rgba(255,255,255,0.03);
  backdrop-filter:blur(10px);
  display:flex;
  align-items:center;
  justify-content:space-between;
  z-index:120;
  border-bottom:1px solid rgba(255,255,255,0.05);
}

.brand { display:flex; gap:10px; align-items:center; }
.logo {
  width:38px; height:38px;
  border-radius:10px;
  background:linear-gradient(135deg,var(--primary),var(--secondary));
  display:flex; align-items:center; justify-content:center;
  font-weight:800; color:#000;
}
.small { font-size:0.85rem; color:#9fbfda; }

/* MAIN LAYOUT */
.chat-wrap {
  display:flex;
  flex:1;
  margin-top:64px; /* header height */
  overflow:hidden;
}

.sidebar {
  width:260px;
  background:var(--glass);
  padding:12px;
  overflow:auto;
  border-right:1px solid rgba(255,255,255,0.05);
}
.main { flex:1; display:flex; flex-direction:column; }
.messages {
  flex:1; padding:16px; overflow:auto;
  display:flex; flex-direction:column; gap:10px;
  scroll-behavior:smooth;
}
.bubble {
  max-width:72%; padding:12px; border-radius:12px;
  animation:fadeIn 0.25s ease;
}
.bubble.me {
  align-self:flex-end;
  background:linear-gradient(90deg,#00f7ff33,#6c63ff33);
  border:1px solid rgba(255,255,255,0.04);
}
.bubble.peer {
  align-self:flex-start;
  background:rgba(255,255,255,0.03);
}

/* INPUT CONTROLS */
.controls {
  display:flex; gap:8px; padding:12px;
  align-items:center; border-top:1px solid rgba(255,255,255,0.04);
}
.input {
  flex:1; padding:10px;
  border-radius:10px; border:none;
  background:rgba(255,255,255,0.05);
  color:#fff; outline:none;
}
.btn {
  padding:10px 12px; border-radius:10px; border:none;
  background:var(--primary); color:#fff;
  cursor:pointer; transition:0.25s;
}
.btn:hover { background:#7a73ff; transform:translateY(-1px); }

/* SETTINGS PANEL (TOP) */
#settings-panel {
  position:fixed;
  top:-100vh; left:50%;
  transform:translateX(-50%);
  width:90%; max-width:420px;
  background:rgba(15,15,20,0.9);
  backdrop-filter:blur(14px);
  border-radius:var(--radius);
  padding:20px;
  box-shadow:var(--shadow);
  transition:top 0.4s ease, opacity 0.3s ease;
  opacity:0; z-index:200;
  border:1px solid rgba(255,255,255,0.08);
}
#settings-panel.active { top:80px; opacity:1; }

#settings-panel h3 {
  color:var(--secondary);
  text-align:center;
  font-weight:700;
  margin-bottom:14px;
}
.settings-section { margin-bottom:18px; }
.settings-section h4 {
  font-size:13px; color:var(--secondary);
  text-transform:uppercase; margin-bottom:8px;
}
#settings-panel button {
  width:100%; padding:10px 12px;
  border:none; border-radius:10px;
  background:linear-gradient(135deg,var(--primary),var(--secondary));
  color:#fff; cursor:pointer; margin-top:6px;
}
#settings-panel button:hover {
  background:linear-gradient(135deg,#5a54ff,#00d9ff);
}

/* OVERLAY */
#overlay {
  position:fixed; inset:0;
  background:rgba(0,0,0,0.4);
  backdrop-filter:blur(3px);
  z-index:150; opacity:0;
  visibility:hidden; transition:0.3s ease;
}
#overlay.active { opacity:1; visibility:visible; }

@keyframes fadeIn {
  from{opacity:0; transform:translateY(8px);}
  to{opacity:1; transform:translateY(0);}
}

/* MOBILE */
@media(max-width:768px){
  .sidebar{display:none;}
  .chat-wrap{margin-top:60px;}
  .logo{width:34px;height:34px;}
}
</style>
</head>
<body>
<header>
  <div class="brand"><div class="logo">DA</div><div><strong>Da-ChatGPT</strong><div class="small" id="status">Offline</div></div></div>
  <div id="userInfo" class="small">Not logged</div>
</header>

<div class="chat-wrap">
  <aside class="sidebar">
    <div><strong>Contacts</strong></div>
    <div id="contacts"></div>
    <hr />
    <div><strong>Invites</strong></div>
    <div id="invites"></div>
  </aside>

  <main class="main">
    <div class="messages" id="messages"></div>
    <div class="controls">
      <input id="textIn" class="input" placeholder="Envoyer un message..." />
      <button class="btn" id="sendBtn">Send</button>
      <button class="btn" id="recBtn">ðŸŽ¤</button>
      <input type="file" id="fileInput" style="display:none" />
      <button class="btn" id="attachBtn">ðŸ“Ž</button>
    </div>
  </main>
</div>

<script type="module">
  // Firebase config - REPLACE
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
  import { getAuth, signInWithPopup, GoogleAuthProvider, GithubAuthProvider, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-auth.js";

  const firebaseConfig = {
    apiKey: "REPLACE_APIKEY",
    authDomain: "REPLACE_AUTHDOMAIN",
    projectId: "REPLACE_PROJECTID",
  };
  const firebaseApp = initializeApp(firebaseConfig);
  const auth = getAuth();
  const providerGoogle = new GoogleAuthProvider();
  const providerGithub = new GithubAuthProvider();

  // Socket.IO
  import { io } from "https://cdn.socket.io/4.7.2/socket.io.esm.min.js";

  let socket = null;
  let currentUser = null;
  let chatKey = null; // base64 string - symmetric AES-GCM key used locally for encrypt/decrypt
  let currentChatId = null;

  // Helpers: webcrypto AES-GCM
  async function generateChatKeyBase64() {
    const key = await crypto.subtle.generateKey({name:'AES-GCM', length:256}, true, ['encrypt','decrypt']);
    const raw = await crypto.subtle.exportKey('raw', key);
    return btoa(String.fromCharCode(...new Uint8Array(raw)));
  }
  async function importKeyFromBase64(b64) {
    const raw = Uint8Array.from(atob(b64), c=>c.charCodeAt(0));
    return crypto.subtle.importKey('raw', raw.buffer, 'AES-GCM', true, ['encrypt','decrypt']);
  }
  async function encryptWithBase64Key(b64, text) {
    const key = await importKeyFromBase64(b64);
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const enc = new TextEncoder().encode(text);
    const ct = await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, enc);
    return { ciphertext: btoa(String.fromCharCode(...new Uint8Array(ct))), iv: btoa(String.fromCharCode(...iv)) };
  }
  async function decryptWithBase64Key(b64, ciphertextB64, ivB64) {
    const key = await importKeyFromBase64(b64);
    const ct = Uint8Array.from(atob(ciphertextB64), c=>c.charCodeAt(0));
    const iv = Uint8Array.from(atob(ivB64), c=>c.charCodeAt(0));
    const pt = await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct.buffer);
    return new TextDecoder().decode(pt);
  }

  // UI refs
  const statusEl = document.getElementById('status');
  const userInfo = document.getElementById('userInfo');
  const contactsEl = document.getElementById('contacts');
  const invitesEl = document.getElementById('invites');
  const messagesEl = document.getElementById('messages');

  // Auth state
  onAuthStateChanged(auth, async user => {
    if (user) {
      currentUser = user;
      userInfo.textContent = user.displayName || user.email;
      statusEl.textContent = 'Online';
      // connect socket with firebase id token
      const idToken = await user.getIdToken();
      socket = io("/", { auth: { token: idToken } });

      socket.on("connect", ()=> console.log("socket connected"));
      socket.on("receive-invite", (inv)=> {
        const div = document.createElement('div');
        div.textContent = `Invite from ${inv.fromUid}`;
        const acceptBtn = document.createElement('button'); acceptBtn.textContent='Accept';
        acceptBtn.onclick = ()=> socket.emit('accept-invite',{inviteId:inv.inviteId});
        div.appendChild(acceptBtn);
        invitesEl.prepend(div);
      });
      socket.on("chat-created", async (payload) => {
        // payload: { chatId, chatKey, peerUid }
        currentChatId = payload.chatId;
        chatKey = payload.chatKey;
        localStorage.setItem('chatKey_'+currentChatId, chatKey);
        addSystemMsg('Chat created with ' + payload.peerUid);
        socket.emit('join-chat', { chatId: currentChatId });
      });
      socket.on("chat-message", async (m) => {
        // decrypt
        const stored = localStorage.getItem('chatKey_'+m.chatId);
        if (!stored) return console.warn('No chatKey');
        const text = await decryptWithBase64Key(stored, m.ciphertext, m.iv);
        addMessageBubble(text, 'peer');
      });

      // load invites API
      const res = await fetch('/api/invites', { headers: { Authorization: 'Bearer ' + await user.getIdToken() } });
      const invites = await res.json();
      invites.forEach(inv => {
        const div = document.createElement('div');
        div.textContent = `Invite from ${inv.from_uid} (status: ${inv.status})`;
        invitesEl.prepend(div);
      });
    } else {
      userInfo.textContent = 'Not logged';
      statusEl.textContent = 'Offline';
    }
  });

  // helpers for UI
  function addMessageBubble(text, cls='me') {
    const el = document.createElement('div');
    el.className = 'bubble ' + (cls==='me' ? 'me' : 'peer');
    el.textContent = text;
    messagesEl.appendChild(el);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  function addSystemMsg(text) {
    const el = document.createElement('div'); el.className='small'; el.textContent=text; messagesEl.appendChild(el);
  }

  // Send message
  document.getElementById('sendBtn').addEventListener('click', async () => {
    const txt = document.getElementById('textIn').value.trim();
    if (!txt) return;
    if (!currentChatId) {
      // create ephemeral chat invitation flow: create chatKey and send invite to peer (selected from query)
      const urlParams = new URLSearchParams(location.search);
      const peer = urlParams.get('peer');
      if (!peer) { alert('No chat selected'); return; }
      const inviteId = 'inv_' + Date.now().toString(36);
      const key = await generateChatKeyBase64();
      // store locally for when chat created
      localStorage.setItem('pending_chatKey_' + inviteId, key);
      // send invite
      socket.emit('send-invite', { toUid: peer, inviteId, chatKey: key });
      addSystemMsg('Invitation sent to ' + peer);
      // also add message to show that message will be sent after accept
      document.getElementById('textIn').value = '';
      return;
    }
    const storedKey = localStorage.getItem('chatKey_' + currentChatId);
    if (!storedKey) return alert('Missing chat key');
    const { ciphertext, iv } = await encryptWithBase64Key(storedKey, txt);
    // persist/send to server
    socket.emit('chat-message', { chatId: currentChatId, ciphertext, iv });
    addMessageBubble(txt, 'me');
    document.getElementById('textIn').value='';
  });

  // Attach / file
  document.getElementById('attachBtn').addEventListener('click', ()=> document.getElementById('fileInput').click());
  document.getElementById('fileInput').addEventListener('change', async (e)=>{
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = async () => {
      const dataUrl = reader.result;
      // treat as normal message: encrypt dataUrl
      if (!currentChatId) return alert('No chat created yet');
      const key = localStorage.getItem('chatKey_' + currentChatId);
      const { ciphertext, iv } = await encryptWithBase64Key(key, dataUrl);
      socket.emit('chat-message', { chatId: currentChatId, ciphertext, iv });
      addMessageBubble('[Image sent]', 'me');
    };
    reader.readAsDataURL(file);
  });

  // Voice input (SpeechRecognition)
  let recognition = null;
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const Rec = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new Rec();
    recognition.lang = 'en-US';
    recognition.interimResults = false;
    recognition.onresult = (ev) => {
      const text = ev.results[0][0].transcript;
      document.getElementById('textIn').value = text;
    };
  }
  document.getElementById('recBtn').addEventListener('click', ()=> {
    if (!recognition) return alert('Voice not supported');
    recognition.start();
  });

  // AI query example: if ?ai=1 in url, send input to AI proxy /api/ai-query
  const urlParams = new URLSearchParams(location.search);
  if (urlParams.get('ai') === '1') {
    addSystemMsg('AI mode: type a question and press Send. Responses come from Gemini.');
    // intercept send to call AI
    const oldHandler = document.getElementById('sendBtn').onclick;
    document.getElementById('sendBtn').addEventListener('click', async ()=>{
      const txt = document.getElementById('textIn').value.trim();
      if (!txt) return;
      addMessageBubble(txt, 'me');
      document.getElementById('textIn').value='';
      // show loading bubble
      const loadingEl = document.createElement('div'); loadingEl.className='bubble peer'; loadingEl.textContent = 'AI is thinking...'; messagesEl.appendChild(loadingEl);
      // call server proxy
      const res = await fetch('/api/ai-query', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ prompt: txt }) });
      const data = await res.json();
      loadingEl.remove();
      const aiText = (data?.data?.choices?.[0]?.message?.content) || JSON.stringify(data);
      addMessageBubble(aiText, 'peer');
      // optionally speak response in detected language:
      const utter = new SpeechSynthesisUtterance(aiText);
      speechSynthesis.speak(utter);
    }, { once: true });
  }

  // show some contacts (mock)
  ['friend1','friend2','friend3'].forEach(uid => {
    const d = document.createElement('div');
    d.textContent = uid;
    d.style.cursor='pointer';
    d.onclick = ()=> {
      // navigate to same page with peer selected
      location.search = '?peer=' + uid;
      addSystemMsg('Selected ' + uid + ' - press Send to invite.');
    };
    contactsEl.appendChild(d);
  });
</script>
</body>
</html>